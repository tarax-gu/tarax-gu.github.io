import{_ as a,r as e,o as d,m as r,b as n,w as t,p as _,i as h,a as l,e as p}from"./index-DBKJjhjt.js";const f={},b=i=>(_("data-v-b86bd4cb"),i=i(),h(),i),m={class:"container"},v=b(()=>l("div",{class:"content"},[l("h1",{id:"section3"},"第三章 内存管理"),l("h2",{id:"section3.1"},"3.1 内存管理概念"),l("h3",{id:"section3.1.1"},"3.1.1 内存管理的基本原理和要求"),l("ul",null,[l("li",null," 内存空间的分配和回收。用户程序变为系统可执行的程序通常需要编译、链接、装入。 装入内存时有三种方式：绝对装入、可重定位装入、动态运行装入。 链接时有三种方式：静态链接、装入时动态链接、运行时动态链接。 "),l("li",null,"地址转换。逻辑地址和物理地址的转换。"),l("li",null,"内存空间的扩充。虚拟地址等方法。"),l("li",null,"内存共享。纯代码可以被共享。"),l("li",null,"存储保护。确保每个进程有一个单独的内存空间，可采用以下方法：上下限寄存器或是重定位寄存器和界地址寄存器。")]),l("h3",{id:"section3.1.2"},"3.1.2 连续分配管理方式"),l("ul",null,[l("li",null,"单一连续分配。"),l("li",null,"固定分区分配。"),l("li",null,"动态分区分配。顺序查找：首次适应算法、邻近适应算法、最佳适应算法、最坏适应算法。索引搜索：快速适应算法、伙伴系统、哈希算法。")]),l("h3",{id:"section3.1.3"},"3.1.3 基本分页存储管理"),l("ul",null,[p("将内存空间分为若干固定大小的分区，称为页。 "),l("li",null," 页面和页面大小。进程逻辑地址空间的每一个页面有一个页号(从0开始); 内存空间中的每个页框也有一个编号，称为页框(或物理块号，从0开始)，页号与页框号一一对应。 "),l("li",null," 地址结构。逻辑地址结构一般为页号+页内偏移。 "),l("li",null," 页表。每个页表项由页号和块号组成，记录了页面在内存中对应的物理块号。 "),l("li",null," 基本地址变换机构。将逻辑地址转化为内存中的物理地址，通过查页表去计算。 页表地址和页表长度通常存储在页表寄存器里。 "),l("li",null," 具有快表的地址变换机构。快表为具有并行能力的高速缓冲存储器，地址变换过程中， 会先查快表，若查到，就不用再查页表，这样，存取数据仅用一次访存就可以实现。 "),l("li",null,"两级页表。实际上，页表通常很大，这时采用多级页表就能节省非常多的空间。 二级页表的逻辑地址：页目录号+页号+页内偏移。 ")]),l("h3",{id:"section3.1.4"},"3.1.4 基本分段存储管理"),l("ul",null,[l("li",null,"分段。分段系统将逻辑地址空间划分为大小不等的段。逻辑地址结构为：段号+段内偏移量。"),l("li",null,"段表。段表项：段号+段长+段在主存中的起始地址。"),l("li",null,"地址变换机构。地址转换过程和分页存储管理的地址转换类似。"),l("li",null,"段的共享与保护。段共享非常容易，只需要给共享的代码段建立一个段表项。 段的保护和页保护策略类似，存储控制保护或者地址越界保护。 ")]),l("h3",{id:"section3.1.5"},"3.1.5 段页式存储管理"),l("p",null," 分页存储管理能有效地提高内存利用率，分段存储管理能反映程序逻辑结构并有利于段的共享和保护，将两者结合起来，便形成了段页式存储管理方式。 在段页式系统中，进程的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后将每段分成若干大小固定的页，内存空间分成大小相同的页。 进程的逻辑地址分为三部分：段号、页号、页内偏移量。 为了实现地址变换，每个进程拥有一个段表，每个段表有一张页表，其地址变换就是从段表查页表，从页表查物理地址。 "),l("h2",{id:"section3.2"},"3.2 虚拟内存管理"),l("h3",{id:"section3.2.1"},"3.2.1 虚拟内存的基本概念"),l("ul",null,[l("li",null," 传统存储方式的特征。一次性、驻留性。 "),l("li",null," 局部性原理。时间局部性、空间局部性。 "),l("li",null," 虚拟存储器的定义和特征。多次性、对换性、虚拟性。 "),l("li",null," 虚拟内存计数的实现。基于离散分配的内存管理方式。三种实现方式：请求分页存储管理、请求分段存储管理、请求段页式存储管理。 需要硬件支持：一定容量内存外村、页表机制(段表机制)，中断机构，地址变换机构。 ")]),l("h3",{id:"section3.2.2"},"3.2.2 请求分页管理方式"),l("ul",null,[l("li",null," 页表机制。由于实现了请求调页功能，在页表项中增加4个字段： 状态位(标记是否调入内存)、访问字段(置换算法的参考)、修改位(是否修改)、外存地址(供调入时参考) "),l("li",null," 缺页中断机制。当访问的页面不在内存中时，产生一个缺页中断。 "),l("li",null," 地址变换机构。按照快表，页表的顺序进行查找，命中时要修改页表项中的相应字段。 ")]),l("h3",{id:"section3.2.3"},"3.2.3 页框分配"),l("ul",null,[l("li",null,"驻留集。一个进程分配的页框的集合就是该进程的驻留集。"),l("li",null,"内存分配策略。进行内存分配时，固定和可变分配，进行置换时，全局和局部置换。"),l("li",null,"物理块调入算法。平均分配、按比例分配、优先权分配。"),l("li",null,"调入页面的时机。预调页、请求调页。")]),l("h3",{id:"section3.2.4"},"3.2.4 页面置换算法"),l("ul",null,[l("li",null,"最佳置换算法。淘汰最长时间内不被访问的页面。"),l("li",null,"先进先出置换算法。淘汰最早进入内存的页面。"),l("li",null,"最近最久未使用置换算法。淘汰最近最长时间按未使用的页面。"),l("li",null,"时钟置换算法。简单型：循环检查访问位，淘汰访问位为0的页面，若访问为为1，则置0。 改进型：增加修改位，进行多轮扫描，选择最佳淘汰页，减少磁盘IO。 ")]),l("h3",{id:"section3.2.5"},"3.2.5 内存映射文件"),l("p",null," 内存映射文件是操作系统项应用程序提供的一个系统调用，通过该调用， 可以将一个文件映射到期虚拟地址空间的某个区域，就可以用访问内存的方式读写文件。 进程可以通过共享内存来通信，实际上就是相同文件映射到进程的虚拟地址空间。 "),l("h3",{id:"section3.2.6"},"3.2.6 虚拟存储器性能影响因素"),l("ul",null,[l("li",null,"缺页率。分配块的数量及大小、页面置换算法。"),l("li",null,"写回磁盘的频率。")]),l("br"),l("br"),l("br"),l("br"),l("br")],-1));function w(i,x){const u=e("el-col"),o=e("el-anchor-link"),c=e("el-anchor"),s=e("el-row");return d(),r("div",m,[n(s,{style:{height:"100%"}},{default:t(()=>[n(u,{span:18},{default:t(()=>[v]),_:1}),n(u,{span:6,style:{}},{default:t(()=>[n(c,null,{default:t(()=>[n(o,{href:"#section1",title:"part1"}),n(o,{href:"#section1.1",title:"part2"}),n(o,{href:"#section1.1.1",title:"part3"})]),_:1})]),_:1})]),_:1})])}const k=a(f,[["render",w],["__scopeId","data-v-b86bd4cb"]]);export{k as default};
