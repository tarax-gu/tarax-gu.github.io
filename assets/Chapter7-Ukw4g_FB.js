import{_ as d,r as t,o as r,m as h,b as n,w as o,p as _,i as p,a as l,e}from"./index-DBKJjhjt.js";const m={},f=i=>(_("data-v-8ce6ef2e"),i=i(),p(),i),B={class:"container"},g=f(()=>l("div",{class:"content"},[l("h1",{id:"section7"},"第七章 查找"),l("h2",{id:"section7.1"},"7.1 查找的基本概念"),l("p",null," 在数据集合中寻找满足某种条件的数据元素的过程称为查找。 "),l("h2",{id:"section7.2"},"7.2 顺序查找和折半查找"),l("h3",{id:"section7.2.1"},"7.2.1 顺序查找"),l("p",null," 作为一种最直观的查找方法，就是从线性表的一段开始，逐个检查关键字是否满足给定条件。时间复杂度O(n)。 "),l("h3",{id:"section7.2.2"},"7.2.2 折半查找"),l("p",null," 折半查找又被称为二分查找，仅用于有序表。其基本思想为：先将key值与有序线性表中间位置的元素比较。 若相等，则查找成功，若不等，则说明key值在线性表的左半或者右半部分。 折半查找只适用于顺序查找结构。 "),l("pre",null,[e("                "),l("code",null,`
    int bsearch(int a[],int goal,int start,int end){
        int left = start,right = end;
        int mid;
        while(left <= right){
            mid = (left+right)/2;
            if(a[mid]==goal) return mid;
            else if(a[mid]>goal){
                right = mid-1;
            }else{
                left = mid+1;
            }
        }
        return -1;
    }
                `),e(`
            `)]),l("h3",{id:"section7.2.3"},"7.2.3 分块查找"),l("p",null," 分块查找又被称为索引顺序查找，它吸取了顺序查找和折半查找各自的优点。 将线性表分为若干的查找块，块内无序，块间有序，建立索引表存储块的关键字。 利用折半查找查找索引块，在索引块内顺序查找。 "),l("h2",{id:"section7.3"},"7.3 树形查找"),l("h3",{id:"section7.3.1"},"7.3.1 二叉排序树(BST)"),l("ul",null,[e(" 二叉排序树具有如下特征：左子树结点值 < 根结点值 < 右子树结点值，且其左子树右子树均为二叉排序树。 "),l("li",null,"查找。从根结点开始，逐层向下。"),l("li",null,"插入。即在查找的过程中插入定值。"),l("li",null,"构造。即依次插入结点。"),l("li",null,"删除。右子树为空，则用左子女填补，左子树为空则用右子树填补，都不为空则在右子树上找中序第一个子女填补。"),l("li",null,"查找效率。和树的高度有关")]),l("h3",{id:"section7.3.2"},"7.3.2 平衡二叉树"),l("ul",null,[e(" 为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除结点时，要保证结点左右子树的高度差不超过1，这样的二叉树被称为平衡二叉树。 "),l("li",null,"插入。为了保证插入结点后二叉树仍然平衡，需要进行旋转。LL旋转，RR旋转，LR旋转，RL旋转。"),l("li",null,"删除。删除叶节点后进行回溯找到第一个不平衡的子树进行调整，和插入的调整方式一样。"),l("li",null,"查找。和二叉排序树查找相同，效率为O(logn)")]),l("h3",{id:"section7.3.3"},"7.3.3 红黑树"),l("ul",null,[e(" 红黑树满足如下条件：根结点和叶结点（虚构的外部节点）是黑色的，不存在两个相邻的红结点，每个结点到叶结点黑高相同。 "),l("li",null,"从根到叶结点的最长路径不超过最短路径的两倍"),l("li",null,"插入。新插入的结点初始为红色，若其叔结点是黑色的，进行旋转即可， 若其叔节点为红色，将其爷结点染成红色，父节点和叔结点染成黑色。指针上移不断进行调整。"),l("li",null,"删除。删除的处理较为复杂。")]),l("h2",{id:"section7.4"},"7.4 B树和B+树"),l("h3",{id:"section7.4.1"},"7.4.1 B树的基本操作"),l("ul",null,[e(" 一棵m阶B树或为空树，或为满足以下特性的m叉树： "),l("li",null,"每个结点至多有m棵子树，即至多有m-1个关键字。"),l("li",null,"若根节点不是叶结点，则至少有两颗子树，即至少有一个关键字。"),l("li",null,"除根节点外所有的非叶结点至少有[m/2](向上取整)棵子树，即至少[m/2]-1个关键字"),l("li",null,"非叶结点由关键字和指针构成。"),l("li",null,"所有的叶结点在同一层，可视为虚拟的外部节点。"),e(" 关于B树的操作： "),l("li",null,"查找。和二叉排序树类似，先找结点，再在结点内找关键字。"),l("li",null,"B树的高度。即最小为log(n+1)/logm。"),l("li",null,"插入。先定位，后插入，如果超出结点关键字上限，进行分裂。"),l("li",null,"删除。需要进行结点合并。")]),l("h3",{id:"section7.4.2"},"7.4.2 B+树"),l("p",null," B+树为变形的B树，即在所有叶结点存储关键字信息并指向记录。 即可支持顺序访问。 "),l("h2",{id:"section7.5"},"7.5 散列(hash)表"),l("h3",{id:"section7.5.1"},"7.5.1 散列表的基本概念"),l("ul",null,[l("li",null,"散列函数(哈希函数)：把关键字映射为对应地址函数。当两个以上的关键字映射到同一地址时，需要进行冲突处理。"),l("li",null,"散列表(哈希表)：根据关键字直接进行访问的数据结构。")]),l("h3",{id:"section7.5.2"},"7.5.2 散列函数的构造方法"),l("ul",null,[l("li",null,"直接定址法。"),l("li",null,"除留余数法。"),l("li",null,"数字分析法。"),l("li",null,"平方取中法。")]),l("h3",{id:"section7.5.3"},"7.5.3 处理冲突的方法"),l("ul",null,[l("li",null,"开放定址法。线性探测、平方探测、双散列法、伪随机法。"),l("li",null,"拉链法。")]),l("h3",{id:"section7.5.4"},"7.5.4 散列查找及性能分析"),l("ul",null,[l("li",null,"查找。有记录且相等，查找成功，若不等计算下一散列地址；无记录查找失败。"),l("li",null,"装填因子。即一个表的装满程度，平均查找长度依赖于装填因子。")]),l("br"),l("br"),l("br"),l("br"),l("br")],-1));function b(i,k){const s=t("el-col"),c=t("el-anchor-link"),u=t("el-anchor"),a=t("el-row");return r(),h("div",B,[n(a,{style:{height:"100%"}},{default:o(()=>[n(s,{span:18},{default:o(()=>[g]),_:1}),n(s,{span:6,style:{}},{default:o(()=>[n(u,null,{default:o(()=>[n(c,{href:"#section1",title:"part1"}),n(c,{href:"#section1.1",title:"part2"}),n(c,{href:"#section1.1.1",title:"part3"})]),_:1})]),_:1})]),_:1})])}const v=d(m,[["render",b],["__scopeId","data-v-8ce6ef2e"]]);export{v as default};
