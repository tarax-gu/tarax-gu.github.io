import{_ as a,r as e,o as d,m as r,b as n,w as u,p as _,i as p,a as l,e as c}from"./index-DBKJjhjt.js";const f={},C=i=>(_("data-v-ea41c8ff"),i=i(),p(),i),M={class:"container"},R=C(()=>l("div",{class:"content"},[l("h1",{id:"section3"},"第三章 存储系统"),l("h2",{id:"section3.1"},"3.1 存储器概述"),l("h3",{id:"section3.1.1"},"3.1.1 存储器的分类"),l("ul",null,[l("li",null,"按存储层次分类。主存(内存),辅存(外存)，高速缓冲存储器(cache)。"),l("li",null,"按存储介质分类。磁存储、半导体存储、光存储。"),l("li",null,"按存取方式分类。随机存储器(RAM)、只读存储器(ROM),串行访问存储器。"),l("li",null,"按信息的可保存性分类。易失性存储器(RAM),非易失性存储器。")]),l("h3",{id:"section3.1.2"},"3.1.2 存储器的性能指标"),l("ul",null,[l("li",null,"存储容量。"),l("li",null,"单位成本。"),l("li",null,"存取速度。")]),l("h3",{id:"section3.1.3"},"3.1.3 多级层次的存储系统"),l("p",null," 为了了解决上述三个条件的相互制约，计算机系统采用多级存储器结构，上一层的存储器作为低一层存储器的高速缓存。 "),l("h2",{id:"section3.2"},"3.2 主存存储器"),l("h3",{id:"section3.2.1"},"3.2.1 SRAM芯片和DRAM芯片"),l("ul",null,[c(" 半导体存储器分为RAM和ROM. "),l("li",null," SRAM(静态随机存储器)。使用六晶体管(MOS)记忆信息，非破坏性读出。 "),l("li",null," DRAM(动态随机存储器)。利用电容中的电荷存储信息。需要定时刷新(集中刷新、分散刷新、异步刷新)和读后再生。 ")]),l("h3",{id:"section3.2.2"},"3.2.2 只读存储器"),l("ul",null,[l("li",null," 特点。结构简单、非易失性。 "),l("li",null," ROM类型。掩模式只读存储器、一次可编程只读存储器，可擦除可编程只读存储器，flash存储器，固态硬盘。 ")]),l("h3",{id:"section3.2.3"},"3.2.3 主存储器的基本组成"),l("ul",null,[l("li",null,"MAR,MDR。"),l("li",null,"地址寄存器、地址译码器。"),l("li",null,"数据线、地址线、控制线。"),l("li",null,"记忆单元。")]),l("h3",{id:"section3.2.4"},"3.2.4 多模块存储器"),l("ul",null,[l("li",null,"单体多字存储器。"),l("li",null,"多体并行存储器。高位交叉编址、低位交叉编址。轮流启动、同时启动。"),l("li",null,"时钟置换算法。简单型：循环检查访问位，淘汰访问位为0的页面，若访问为为1，则置0。 改进型：增加修改位，进行多轮扫描，选择最佳淘汰页，减少磁盘IO。 ")]),l("h2",{id:"section3.3"},"3.3 主存储器和CPU的连接"),l("h3",{id:"section3.3.1"},"3.3.1 连接原理"),l("ul",null,[l("li",null,"通过数据总线、地址总线、控制总线连接。"),l("li",null,"传输速率与数据总线的位数和工作频率的乘积成正比。"),l("li",null,"地址总线的尾数决定可寻址的最大内存空间。"),l("li",null,"控制总线指出总线周期类型和本次输入输出操作完成的时刻。")]),l("h3",{id:"section3.3.2"},"3.3.2 主存容量的扩展"),l("ul",null,[l("li",null,"位扩展法。"),l("li",null,"字扩展法。"),l("li",null,"字位同时扩展法。")]),l("h3",{id:"section3.3.3"},"3.3.3 存储芯片的地址分配和片选"),l("ul",null,[l("li",null,"线选法。"),l("li",null,"译码片选法。")]),l("h3",{id:"section3.3.4"},"3.3.4 存储器与CPU的连接"),l("ul",null,[l("li",null,"合理选择存储芯片。"),l("li",null,"地址线的连接。"),l("li",null,"数据线的连接。"),l("li",null,"读写命令线的连接。"),l("li",null,"片选线的连接。")]),l("h2",{id:"section3.4"},"3.4 外部存储器"),l("h3",{id:"section3.4.1"},"3.4.1 磁盘存储器"),l("ul",null,[l("li",null," 磁盘存储器。 "),l("li",null," 磁盘阵列。 ")]),l("h3",{id:"section3.4.2"},"3.4.2 固态硬盘"),l("ul",null,[l("li",null," 固态硬盘的特性。 "),l("li",null," 磨损均衡。 ")]),l("h2",{id:"section3.5"},"3.5 高速缓冲存储器"),l("h3",{id:"section3.5.1"},"3.5.1 程序访问的局部性原理"),l("p",null," 时间局部性和空间局部性。 "),l("h3",{id:"section3.5.2"},"3.5.2 Cache的基本工作原理"),l("ul",null,[l("li",null,"读请求。"),l("li",null,"写请求。"),l("li",null,"命中率。")]),l("h3",{id:"section3.5.3"},"3.5.3 Cache与主存的映射方式"),l("ul",null,[c(" Cache中需要一个标志位，指出是哪一块的副本；一个有效位，指出Cache行中的信息是否有效。 "),l("li",null,"直接映射。主存中每一块只能装入Cache中唯一位置，发生冲突时无条件替换。"),l("li",null,"全相联映射。主存中每一块只能装入Cache中任意位置。"),l("li",null,"组相联映射。即直接映射和全相联映射的一种折中。")]),l("h3",{id:"section3.5.4"},"3.5.4 Cache中主存块的替换算法"),l("ul",null,[l("li",null,"随机算法。"),l("li",null,"先入先出算法。"),l("li",null,"LRU算法。"),l("li",null,"最不经常使用算法。")]),l("h3",{id:"section3.5.5"},"3.5.5 Cache的一致性问题"),l("ul",null,[c(" 对于Cache中写操作命中，有两种处理方法。 "),l("li",null," 全写法。可以加写缓冲区解决速度不匹配的问题。 "),l("li",null," 回写法。增加以为修改位，在换出的时候根据修改位写入主存。 "),c(" 对于写操作不命中： "),l("li",null,"写分配法。更新主存单元，将该块调入Cache，常与回写法合用。"),l("li",null,"非写分配法。只更新贮存单元，常与全写法合用。")]),l("h2",{id:"section3.6"},"3.6 虚拟存储器"),l("h3",{id:"section3.6.1"},"3.6.1 虚拟存储器的基本概念"),l("p",null," 虚拟存储器将主存和辅存的地址空间统一编址，形成一个庞大的地址空间。 用户编程涉及的地址为虚地址或逻辑地址，实际的主存单元地址为实地址或物理地址。 虚拟存储器采用回写法，采用全相联映射。 "),l("h3",{id:"section3.6.2"},"3.6.2 页式虚拟存储器"),l("ul",null,[l("li",null,"页表。有效位、脏位、引用位(替换策略)。"),l("li",null,"地址转化。"),l("li",null,"快表。"),l("li",null,"具有TLB和Cache的多级存储系统。")]),l("h3",{id:"section3.6.3"},"3.6.3 段式虚拟存储器"),l("p",null," 虚拟地址为段号和段内地址。段表项：段首址、装入位、段长。 "),l("h3",{id:"section3.6.4"},"3.6.4 段页式虚拟存储器"),l("p",null," 把程序按逻辑结果分段，再将段划分成固定大小的页。 虚地址位段号、段内页号、页内地址。 "),l("br"),l("br"),l("br"),l("br"),l("br")],-1));function m(i,A){const o=e("el-col"),t=e("el-anchor-link"),s=e("el-anchor"),h=e("el-row");return d(),r("div",M,[n(h,{style:{height:"100%"}},{default:u(()=>[n(o,{span:18},{default:u(()=>[R]),_:1}),n(o,{span:6,style:{}},{default:u(()=>[n(s,null,{default:u(()=>[n(t,{href:"#section1",title:"part1"}),n(t,{href:"#section1.1",title:"part2"}),n(t,{href:"#section1.1.1",title:"part3"})]),_:1})]),_:1})]),_:1})])}const S=a(f,[["render",m],["__scopeId","data-v-ea41c8ff"]]);export{S as default};
